Python常见的错误汇总

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误：

TypeError: 'NoneType' object is not callable

【错误分析】我是在别的文件中写了一个函数，然后在python console调用使用该函数，出现了上述错误。原因是因为没有对别的文件中函数进行编译，只要打开该调用函数的文件，然后点击运行，之后再在python console中调用使用该函数就不会报错。

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误:

【错误分析】第二个参数必须为类，否则会报TypeError，所以正确的应该是这样的:

但如果第二个参数是类型对象，则不会报上面的错误，是允许的，比如说:

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误:

【错误分析】这个涉及到调用顺序问题，即解析方法的MRO调用顺序，在Python2.7版本之后，这样调用会报错，

必须是子类先放前面，然后才是父类.如下所示，方不会报错.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误:

【错误分析】foo()未带参数self,也未带cls参数,属于类的静态方法，类的静态方法调用，实例不能直接调用，需要再声明一个静态方法

或者通过@staticmethod来调用

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误:

【错误分析】__dict__是实例的特殊属性，但在内建属性中，不存在__dict__属性，一般的情况是:

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误:

【错误分析】如果定义了构造器，它不应当返回任何对象，因为实例对象是自动在实例化调用后返回的。相应地，__init__()就不应当返回任何对象(应当为None);否则就可能出现冲突，因为只能返回实例。试着返回非None的任何其他对象都会导致TypeError异常

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误:

【错误分析】不要误以为元组里有两个参数，将元组传进去就可以了，实际上元祖作为一个整体只是一个参数，

实际需要两个参数，所以报错。必需再传一个参数方可.

更常用的用法: 在前面加*,代表引用元组

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误:

【错误分析】在C++,Python中默认参数从左往右防止，而不是相反。这可能跟参数进栈顺序有关。

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误:

【错误分析】这是Python中字典键错误的提示，如果想让程序继续运行，可以用字典中的get方法，如果键存在，则获取该键对应的值，不存在的，返回None,也可打印提示信息.

错误:

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误:

【错误分析】join是split的逆方法，是非常重要的字符串方法，但不能用来连接整数型列表，所以需要改成:

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误:

【错误分析】Python中原始字符串以r开头，里面可以放置任意原始字符，包括\，包含在字符中的\不做转义。

但是，不能放在末尾！也就是说，最后一个字符不能是\，如果真 需要的话，可以这样写:

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

代码:

错误:

【错误分析】因所用的Python版本2.7,比较高的版本，raise触发的异常，只能是自定义类异常，而不能是字符串。所以会报错，字符串改为自定义类，就可以了。

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误：

执行上面一段代码，错误如下:

【错误分析】Python中调用类的方法，必须与实例绑定，或者调用自身.

ClassName.method(x, 'Parm')

ClassName.method(self)

所以上面代码，要调用Super类的话，只需要加个self参数即可。

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

【错误分析】reload期望得到的是对象，所以该模块必须成功导入。在没导入模块前，不能重载.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误

*args，才是将元组中的每个元素作为参数

错误：

【错误分析】错误原因**匹配并收集在字典中所有包含位置的参数，但传递进去的却是个元祖。

所以修改传递参数如下:

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

【错误分析】在函数hider()内使用了内置变量open，但根据Python作用域规则LEGB的优先级:

先是查找本地变量==》模块内的其他函数==》全局变量==》内置变量，查到了即停止查找。

所以open在这里只是个字符串，不能作为打开文件来使用，所以报错，更改变量名即可。

可以导入__builtin__模块看到所有内置变量：异常错误、和内置方法

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误：

【错误分析】(1)的类型是整数，所以不能与另一个元祖做合并操作，如果只有一个元素的元祖，应该用(1,)来表示

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误：

【错误分析】字典中的键必须是不可变对象，如(整数，浮点数，字符串，元组).

可用hash()判断某个对象是否可哈希

但列表中元素是可变对象，所以是不可哈希的，所以会报上面的错误.

如果要用列表作为字典中的键，最简单的办法是:

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误：

【错误分析】列表属于可变对象,其append(),sort(),reverse()会在原处修改对象，不会有返回值，

或者说返回值为空，所以要实现反转并排序，不能并行操作，要分开来写。

或者用下面的方法实现:

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误：

【错误分析】class是Python保留字，Python保留字不能做变量名，可以用Class，或klass
同样，保留字不能作为模块名来导入，比如说，有个and.py，但不能将其作为模块导入

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误：

【错误分析】\n默认为换行，\t默认为TAB键.

所以在D:\目录下找不到ew目录下的ext.data文件，将其改为raw方式输入即可。

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误：

【错误分析】错误原因，else, finally执行位置;正确的程序应该如下:

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

错误：

【错误分析】错误原因，列表解析中，x,y必须以数组的方式列出(x,y)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

报错如下:

【错误分析】双下划线的类属性__secretCount不可访问，所以会报无此属性的错误.

解决办法如下:

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

【错误分析】属性错误,归根到底在于元组是不可变类型，所以没有这几种方法.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

【错误分析】空元组和空列表，没有索引为0的项
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

【错误分析】一般出在代码缩进的问题
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

【错误分析】如果文件里面没有行了会报这种异常

有可迭代的对象的next方法,会前进到下一个结果,而在一系列结果的末尾时,会引发StopIteration的异常.

next()方法属于Python的魔法方法，这种方法的效果就是:逐行读取文本文件的最佳方式就是根本不要去读取。

取而代之的用for循环去遍历文件，自动调用next()去调用每一行，且不会报错

【错误分析】接受的变量少了，应该是

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

【错误分析】当映射到字典中的键不存在时候，就会触发此类异常, 或者可以，这样测试

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

【错误分析】一般是代码缩进问题，TAB键或空格键不一致导致

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

【错误分析】代码错误很清晰,SingBird中初始化代码被重写，但没有任何初始化hungry的代码

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

【错误】

【错误分析】元组不可变，所以不可以更改;可以用切片或合并的方式达到目的.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

【错误分析】增强行赋值不能分开来写，必须连着写比如说 +=, *=

参考：http://blog.csdn.net/jerry_1126/article/details/39395899

转载于:https://www.cnblogs.com/wt869054461/p/6839528.html

