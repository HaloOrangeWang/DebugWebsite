read_csv()是python数据分析包pandas里面使用频次较高的函数之一。它包括的参数差不多20个，可能一开始未必需要完整知道每个参数作用。不过，随着使用的深入，实际数据环境愈发复杂，处理的数据上亿行后，就会出现这样那样的问题，这样催促我们反过头来再去理解某些参数的作用。

今天，总结平时使用read_csv()，经常遇到的几个问题。


1、UnicodeDecodeError

read_csv 默认读入文件的编码格式为：utf-8，如果读入文件无法被utf-8编码，就会报上面的错误。

可是我们怎么知道读入文件的编码格式呢？今天，为大家介绍一个这方面的包：chardet，它能返回文件的编码格式。使用前先用pip install chardet，安装一下。 接下里这样编写返回编码格式，file为读入的文件名称。

通过charadet包分析出文件的编码格式后，不管使用 python原生的open, read，还是pandas的read_csv，都可以传入给参数encoding.


2、 sep分隔符

常见文件的分隔符，比如 , \t, csv文件默认为逗号，不过常用的大数据库，比如hive，有时会使用分隔符为\t，这时候就需要调整参数sep. 这类错误比较好解决。


3、读取文件时遇到和列数不对应的行，此时会报错

尤其在读入文件为上亿行的，快读完时，突然报出这个错，此行解析出的字段个数与之前行列数不匹配。
此时，需要调整一个参数：error_bad_lines为false,意思是忽略此行。

pandas.read_csv(***,error_bad_lines=False)

实际项目，读入的文件数据环境比我们预想的复杂。假设我们的数据文件默认分隔符为逗号，然后如果某行的某个单元格取值为：

'山东省, 潍坊市, 青州市'

就光这一个单元格，就会解析出多列，报错那也是自然的，这就要求我们在读入之前对数据做好充分的清洗。


4、EOF inside string starting at line 错误

这个错误在读入文件时，经常也会出现。这类错误需要修改 quoting参数。

df = pd.read_csv(csvfile, quoting=csv.QUOTE_NONE )

默认取值为0，遇到错误时，可以根据文档调整。

