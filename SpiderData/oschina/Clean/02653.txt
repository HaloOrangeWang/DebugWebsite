
Python: 多线程中sql资源抢占问题


报错

Packet sequence number wrong - got 11 expected 1
 pymysql.err.InterfaceError: (0, '')


问题原因

资源抢占的问题原因在于两个线程操作同一个资源，此时这个资源的内容就混乱了，对于两个线程都不能正常服务 此时就可以考虑在一个线程工作的时候，将线程锁定，其他线程无法访问，这就是互斥锁


解决思路

当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制 某个线程要更改共享数据时，先将其锁定，此时资源的状态为"锁定",其他线程不能改变，只到该线程释放资源，将资源的状态变成"非锁定"，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。


解决方法


线程间共享一个数据库连接，但是要在每个execute操作前加上互斥锁。

import threading
lock = threading.Lock()

# 在执行sql钱先上锁,执行完后再解锁
lock.acquire()   # 上锁
cursor.execute(sql)
# 使用其他方法执行sql语句时也可以这样, 例如pandas.readsql(sql)
lock.release()   # 解锁

原理：线程间共享一个数据库连接，为了避免线程间竞争使用带来混乱，当一个线程在使用数据连接时，进行加锁处理，该线程使用完毕，就将数据库连接进行解锁，让其他需要使用的线程使用。这样做，可以将并发变成串行，从而保证操作的有序进行。


在每个线程中，都创建一个数据库连接，各用各的。


使用DBUtils+连接池的方式，每个线程使用数据库连接时在连接池中取用。

