ç‚¹å‡»è“å­—å…³æ³¨Â ğŸ‘†ğŸ‘†

é˜…è¯»æœ¬æ–‡å¤§çº¦éœ€è¦5åˆ†é’Ÿã€‚

golangçˆ¬ççˆ±ç½‘ä»£ç ä¼˜åŒ–åï¼Œè¿è¡ŒæŠ¥äº†å¦‚ä¸‹çš„é”™ï¼Œæ‰¾äº†åŠå°æ—¶æ‰æ‰¾åˆ°åŸå› ï¼Œåœ¨æ­¤è®°å½•ä¸€ä¸‹ã€‚

ä»£ç æ˜¯è¿™æ ·çš„ï¼š

æœ‰ä¸€ä¸ªinterfaceç±»å‹çš„Parserï¼š

typeÂ ParserÂ interfaceÂ {
Â  Â Parser(contents []byte, urlÂ string) ParserResult
Â  Â Serialize() (funcNameÂ string, argsÂ interface{})
}

typeÂ ParserÂ interfaceÂ {
Â  Â Parser(contents []byte, urlÂ string) ParserResult
Â  Â Serialize() (funcNameÂ string, argsÂ interface{})
}

æœ‰ä¸€ä¸ªstructç±»å‹çš„FuncParserï¼š

typeÂ FuncParserÂ structÂ {
Â  Â parser ParserFunc
Â  Â funcNameÂ string
}

typeÂ FuncParserÂ structÂ {
Â  Â parser ParserFunc
Â  Â funcNameÂ string
}

FuncParser å®ç°äº†Parser æ¥å£ï¼š

funcÂ (f *FuncParser)Â Parser(contents []byte, urlÂ string)Â ParserResultÂ {
Â  Â returnÂ f.Parser(contents, url)
}

funcÂ (f *FuncParser)Â Serialize()Â (funcNameÂ string, argsÂ interface{})Â {
Â  Â returnÂ f.funcName,Â nil
}

funcÂ (f *FuncParser)Â Parser(contents []byte, urlÂ string)Â ParserResultÂ {
Â  Â returnÂ f.Parser(contents, url)
}

funcÂ (f *FuncParser)Â Serialize()Â (funcNameÂ string, argsÂ interface{})Â {
Â  Â returnÂ f.funcName,Â nil
}

æŠ›å¼€çˆ¬è™«ä»£ç æ•´ä½“çš„å¤æ‚åº¦ï¼Œå°†ä»£ç ç®€åŒ–åˆ°å¦‚ä¸‹è¿™æ ·ï¼š

type ParserFunc func(url string) string

type FuncParser struct {
 Â  Â parser ParserFunc
}

func (f *FuncParser) Parser(url string) string {
 Â  Â return f.Parser(url)
}

func main() {

funcParse := FuncParser{
 Â  Â  Â  Â func(url string) string {
 Â  Â  Â  Â  Â  Â return url
 Â  Â  Â  Â },
 Â  Â }

funcParse.Parser("http://www.zhenai.com/zhenghun")
}

type ParserFunc func(url string) string

type FuncParser struct {
 Â  Â parser ParserFunc
}

func (f *FuncParser) Parser(url string) string {
 Â  Â return f.Parser(url)
}

func main() {

funcParse := FuncParser{
 Â  Â  Â  Â func(url string) string {
 Â  Â  Â  Â  Â  Â return url
 Â  Â  Â  Â },
 Â  Â }

funcParse.Parser("http://www.zhenai.com/zhenghun")
}

è¿è¡Œä»£ç ååŒæ ·ä¼šæŠ¥é”™ï¼š

runtime: goroutine stack exceeds 1000000000-byte limit
fatal error: stack overflow

runtime stack:
runtime.throw(0x467297, 0xe)
 Â  Â D:/Program Files/Go/go103/src/runtime/panic.go:616 +0x88
runtime.newstack()
 Â  Â D:/Program Files/Go/go103/src/runtime/stack.go:1054 +0x72d
runtime.morestack()
 Â  Â D:/Program Files/Go/go103/src/runtime/asm_amd64.s:480 +0x91

runtime: goroutine stack exceeds 1000000000-byte limit
fatal error: stack overflow

runtime stack:
runtime.throw(0x467297, 0xe)
 Â  Â D:/Program Files/Go/go103/src/runtime/panic.go:616 +0x88
runtime.newstack()
 Â  Â D:/Program Files/Go/go103/src/runtime/stack.go:1054 +0x72d
runtime.morestack()
 Â  Â D:/Program Files/Go/go103/src/runtime/asm_amd64.s:480 +0x91

è¿™ä¸ªç¤ºä¾‹å°±å¾ˆæ˜æ˜¾äº†ï¼ŒFuncParserçš„Parseræ–¹æ³•é‡Œå½¢æˆäº†é€’å½’è°ƒç”¨ï¼ˆè‡ªå·±è°ƒè‡ªå·±ï¼‰ï¼Œé€’å½’è°ƒç”¨è‡ªèº«å¯¼è‡´æ ˆæº¢å‡ºï¼Œå¯¼è‡´æŠ¥é”™ã€‚åº”è¯¥æ”¹æˆè¿™æ ·ï¼šï¼ˆå°å†™çš„parserï¼‰

å®é™…ä¸Šgolandå¼€å‘å·¥å…·é‡Œå·²ç»æç¤ºäº†Recursive Call

ä¸€ä¸å°å¿ƒå°±ä¼šå†™å‡ºè¿™ç§ä»£ç ï¼Œå†çœ‹å¦‚ä¸‹ä»£ç ï¼š

package main

import (
 Â  Â "fmt"
)

type Str string

func (s Str) String() string {
 Â  Â return fmt.Sprintf("Str: %s", s)
}

func main() {
 Â  Â var s Str = "hi"
 Â  Â fmt.Println(s)
}

package main

import (
 Â  Â "fmt"
)

type Str string

func (s Str) String() string {
 Â  Â return fmt.Sprintf("Str: %s", s)
}

func main() {
 Â  Â var s Str = "hi"
 Â  Â fmt.Println(s)
}

åŒæ ·æŠ¥é”™ï¼š

You are implementing Str.String in terms of itself. return fmt.Sprintf("Str: %s", s) will call s.String(), resulting in infinite recursion. Convert s to string first.

This is working as intended, you are using the %s verb to call Str's String method, which uses fmt.Sprint to call Str's String method, and so on.

æ­£å¸¸ä»£ç åº”è¯¥å¦‚ä¸‹ï¼š

å®é™…ä¸Šï¼Œgolandå¼€å‘å·¥å…·é‡Œä¹Ÿä¼šè­¦å‘Šè¯¥é—®é¢˜çš„ï¼š

çœ‹æ¥å¹³æ—¶ç¼–å†™ä»£ç ï¼Œè­¦å‘Šè¿˜æ˜¯å¾—æ³¨æ„çš„ã€‚

é¡¹ç›®ä»£ç è§ï¼šhttps://github.com/ll837448792/crawler

æœ¬æ–‡ç”±â€œå£¹ä¼´ç¼–è¾‘å™¨â€æä¾›æŠ€æœ¯æ”¯æŒ

æœ¬å…¬ä¼—å·å…è´¹æä¾›csdnä¸‹è½½æœåŠ¡ï¼Œæµ·é‡ITå­¦ä¹ èµ„æºï¼Œå¦‚æœä½ å‡†å¤‡å…¥ITå‘ï¼ŒåŠ±å¿—æˆä¸ºä¼˜ç§€çš„ç¨‹åºçŒ¿ï¼Œé‚£ä¹ˆè¿™äº›èµ„æºå¾ˆé€‚åˆä½ ï¼ŒåŒ…æ‹¬ä½†ä¸é™äºjavaã€goã€pythonã€springcloudã€elkã€åµŒå…¥å¼ ã€å¤§æ•°æ®ã€é¢è¯•èµ„æ–™ã€å‰ç«¯Â ç­‰èµ„æºã€‚åŒæ—¶æˆ‘ä»¬ç»„å»ºäº†ä¸€ä¸ªæŠ€æœ¯äº¤æµç¾¤ï¼Œé‡Œé¢æœ‰å¾ˆå¤šå¤§ä½¬ï¼Œä¼šä¸å®šæ—¶åˆ†äº«æŠ€æœ¯æ–‡ç« ï¼Œå¦‚æœä½ æƒ³æ¥ä¸€èµ·å­¦ä¹ æé«˜ï¼Œå¯ä»¥å…¬ä¼—å·åå°å›å¤ã€2ã€‘ï¼Œå…è´¹é‚€è¯·åŠ æŠ€æœ¯äº¤æµç¾¤äº’ç›¸å­¦ä¹ æé«˜ï¼Œä¼šä¸å®šæœŸåˆ†äº«ç¼–ç¨‹ITç›¸å…³èµ„æºã€‚

æ¨èé˜…è¯»ï¼š

Kubernetesï¼Œèµ°è¿›æœªæ¥è½¯ä»¶ä¸–ç•Œçš„æ•²é—¨ç –

æè‡´ç®€æ´çš„markdownç¼–è¾‘ç¥å™¨

å†å²æ–‡ç« ï¼š

çˆ¬å–ççˆ±ç½‘åç”¨æˆ·ä¿¡æ¯å±•ç¤º

ä½ æœ‰å¿…è¦çŸ¥é“çš„ä¸‰ä¸ªé—®é¢˜

ElasticSearchå­¦ä¹ ç¬”è®°ä¹‹åŸç†ä»‹ç»

æœ¬æ–‡ç”±â€œå£¹ä¼´ç¼–è¾‘å™¨â€æä¾›æŠ€æœ¯æ”¯æŒ

æˆ‘æ˜¯å°ç¢—æ±¤ï¼Œæˆ‘ä»¬ä¸€èµ·å­¦ä¹ ã€‚

æ‰«ç å…³æ³¨ï¼Œç²¾å½©å†…å®¹ç¬¬ä¸€æ—¶é—´æ¨ç»™ä½ 

æœ¬æ–‡åˆ†äº«è‡ªå¾®ä¿¡å…¬ä¼—å· - æˆ‘çš„å°ç¢—æ±¤ï¼ˆmysmallsoupï¼‰ã€‚
å¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³» support@oschina.cn åˆ é™¤ã€‚
æœ¬æ–‡å‚ä¸â€œOSCæºåˆ›è®¡åˆ’â€ï¼Œæ¬¢è¿æ­£åœ¨é˜…è¯»çš„ä½ ä¹ŸåŠ å…¥ï¼Œä¸€èµ·åˆ†äº«ã€‚

