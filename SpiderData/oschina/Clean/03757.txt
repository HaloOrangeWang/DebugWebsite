参考资料：虫师-《web接口开发与自动化测试：基于python语言》

日常学习Django框架中，创建了用户模型，但是页面功能验证时候，提示不能进行列表字段操作，debug好久，才找到问题原因，心累。。。

下面是大概过程和解决方案。。。

models.py文件代码：

1 from django.db import models
 2 
 3 # Create your models here.
 4 # 发布会表
 5 class Event(models.Model):
 6     name = models.CharField(max_length=100)              # 发布会标题
 7     limit = models.IntegerField()                        # 参加人数
 8     status = models.BooleanField()                       # 状态
 9     address = models.CharField(max_length=200)           # 地址
10     start_time = models.DateTimeField('event time')      # 发布会时间
11     create_time = models.DateTimeField(auto_now=True)    # 创建时间（自动获取当前时间）
12 
13     def __str__(self):
14         return self.name
15 
16 # 嘉宾表
17 class Guest(models.Model):
18     event = models.ForeignKey('Event','on_delete=models.CASCADE,')   # 关联发布会
19     realname = models.CharField(max_length=64)                       # 姓名
20     phone = models.CharField(max_length=16)                          # 手机号
21     email = models.EmailField()                                      # 邮箱
22     sign = models.BooleanField()                                     # 签到状态
23 create_time = models.DateTimeField(auto_now=True)                # 创建时间（自动获取当前时间）
24 
25 class Meta:
26     unique_together = ("event", "phone")
27 
28 def __str__(self):
29     return self.realname

代码解析：

①、创建发布会表（Event类）和嘉宾表（Guest类）；

②、两个表中默认生成自增ID，但不需要声明；

③、嘉宾表中中通过event字段（字段名event_id）关联发布会ID，ForeignKey()用来创建外键；

④、用发布会ID和手机号作为联合主键，Meta是Django模型类的一个内部类，用于定义行为特性，unique_together用于设置两个字段为联合主键（event和phone）；

命令行执行数据迁移操作：

然后在进入后台管理界面，选择Guests，点击添加，然后保存；

神奇的事情来了，提示如下：

ERRORS:

<class 'sign.admin.GuestAdmin'>: (admin.E108) The value of 'list_display[4]'

检查了很多次代码，在Stack Overflow也找到了类似的问题，最后从头检查代码，才发现是models文件第23行创建时间的代码没有缩进，执行数据迁移时数据库没有对应字段导致的报错。

对应的数据迁移文件代码如下：

1 # Generated by Django 2.0 on 2018-03-05 13:03
 2 
 3 from django.db import migrations, models
 4 
 5 
 6 class Migration(migrations.Migration):
 7 
 8     initial = True
 9 
10     dependencies = [
11     ]
12 
13     operations = [
14         migrations.CreateModel(
15             name='Event',
16             fields=[
17                 ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
18                 ('name', models.CharField(max_length=100)),
19                 ('limit', models.IntegerField()),
20                 ('status', models.BooleanField()),
21                 ('address', models.CharField(max_length=200)),
22                 ('start_time', models.DateTimeField(verbose_name='event time')),
23                 ('create_time', models.DateTimeField(auto_now=True)),
24             ],
25         ),
26         migrations.CreateModel(
27             name='Guest',
28             fields=[
29                 ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
30                 ('realname', models.CharField(max_length=64)),
31                 ('phone', models.CharField(max_length=16)),
32                 ('email', models.EmailField(max_length=254)),
33                 ('sign', models.BooleanField()),
34                 ('event', models.ForeignKey(on_delete='on_delete=models.CASCADE,', to='sign.Event')),
35             ],
36         ),
37     ]

问题的原因是啥捏，我是照着书里面的代码撸的，写的时候也没注意到有一行代码没有缩进，然后导致了没有对应字段，然后保存报错！！！

只想说，对python这种语言来说，缩进格式真的很重要！！！

还有，之前看虫师的selenium自动化那本书的时候，就有很多代码有编写错误，这次又遇到了，不知道说啥了，心好累。。。

最后的解决方案如下：

修改models文件，缩进保持一致，然后重新执行数据迁移操作，由于上次建表少create_time字段，这次执行数据迁移，只是执行了一个更新操作，并未对已有的表字段进行修改。

Django里面，这种操作不是覆盖式的，而是通过新增来解决，对应的迁移文件如下：

1 # Generated by Django 2.0 on 2018-03-05 14:30
 2 
 3 from django.db import migrations, models
 4 
 5 
 6 class Migration(migrations.Migration):
 7 
 8     dependencies = [
 9         ('sign', '0001_initial'),
10     ]
11 
12     operations = [
13         migrations.AddField(
14             model_name='guest',
15             name='create_time',
16             field=models.DateTimeField(auto_now=True),
17         ),
18     ]

最后，重启服务，在界面进行功能验证，发布会下新增宾客，就可以成功保存了。。。

附：django-API文档

PS：收获的教训：

学习过程中，犯错并不可怕，前人的代码，不一定在你的环境完全可编译执行，遇到问题，耐心排查，每次解决问题的过程，就是提高的过程！

