一.异常和错误

什么是错误

语法错误

无法通过python解释器的语法检测

在写代码的时候应该规避掉

逻辑错误

什么是异常

程序运行时发生错误的信号

什么时候容易发生异常

当要处理的内容不确定的时候

有用户参与

有外接数据接入: 从文件中读 , 从网络上获取等

异常信息的查看

当有多行报错的时候是为什么

在嵌套调用的过程中, 内部的代码出了问题, 外部所有的调用的地方都成为报错追溯信息的一部分.

如何解决

从下往上找, 首先找到出错的那一行代码, 如果能看出问题, 就直接解决

不能, 就把报错的最后一行, 错误类型和详细提示贴到百度里, 结合报错的那一行去处理

def func1():

name

def func2():

func1()

def main():

func2()

main()

错误信息:

Traceback (most recent call last):

File "G:/utilities/Python/Python36/projects36/day20/4.异常基础处理.py", line 7, in <module>

main()

File "G:/utilities/Python/Python36/projects36/day20/4.异常基础处理.py", line 6, in main

func2()

File "G:/utilities/Python/Python36/projects36/day20/4.异常基础处理.py", line 4, in func2

func1()

File "G:/utilities/Python/Python36/projects36/day20/4.异常基础处理.py", line 2, in func1                        # 这一行是问题的源头

name

NameError: name 'name' is not defined                    # 如果无法解决, 就将该行信息粘贴到百度去处理

二.异常处理

1.什么是异常

程序运行时发生错误的信号

异常之后的代码就不执行了

2.什么是异常处理

python解释器检测到错误, 触发异常

程序员编写特定的代码, 专门用来捕捉这个异常

如果捕捉成功则进入另外一个处理分支, 执行你为其定制的逻辑, 使程序不会崩溃, 这就是异常处理

3.为什么要进行异常处理

python解释器去执行程序, 检测到了一个错误时, 触发异常, 异常触发后且没被处理的情况下, 程序就在当前异常处终止, 后面的代码不会运行, 非常非常影响用户体验

需要提供一种异常处理机制来增强你程序的健壮性与容错性

4.如何进行异常处理

首先须知, 异常是有程序的错误引起的, 语法上的错误跟异常处理无关, 必须在程序运行前就处理

5.异常处理的几种写法

单分支

try:

被检测的代码块

except 异常类型:

try中一旦检测到此处的异常类型, 就执行这里的逻辑

多分支

try:

被检测的代码块

except 异常类型1:

try中一旦检测到此处的异常类型, 就执行这里的逻辑

except 异常类型2:

try中一旦检测到此处的异常类型, 就执行这里的逻辑

except ...

注:

1. 报错的代码信息会从上向下进行查找, 只要找到和报错类型相符的分支, 就停止查找, 执行这个分支中的代码, 然后直接退出分支

2. 如果找不到能处理和报错类型相同的分支, 会一直往下走, 最后还是没有找到就会报错

多分支合并

try:

被检测的代码块

except (异常类型1, 异常类型2, 异常类型3, ...):

try中一旦检测到此处的异常类型, 就执行这里的逻辑

万能异常

# 写法一:

try:

被检测的代码块

except Exception:

try中出现的所有异常, 都会执行这里的逻辑

# 写法二:

try:

被检测的代码块

except:

try中出现的所有异常, 都会执行这里的逻辑

注:

不会打印错误的信息

as语法

常和万能异常搭配使用

其他单分支或多分支等也是都可以使用的

try:

name

except Exception as e:        # 这里的e就是一个变量, 写什么都可以

print(e)                              # 打印错误信息

注:

Exception 使用as语法, 用来打印错误信息

多分支 + 万能异常

try:

被检测的代码块

except 异常类型1:

try中一旦检测到此处的异常类型, 就执行这里的逻辑

except 异常类型2 as e:                                                        # 这里也可以使用as语法的哦!

try中一旦检测到此处的异常类型, 就执行这里的逻辑

except Exception as e:

print(e)

不满足上面的异常类型时, 都会执行这里的逻辑

注:

万能异常永远在异常处理的最下面

else分支

try:

被检测的代码块

except 异常类型:

try中一旦检测到此处的异常类型, 就执行这里的逻辑

else:

当try中代码不发生异常的时候, 走else分支

注: 应用场景

发邮件, 当网络稳定的时候或邮箱地址错误时, 重新发送

当发送成功时, 进行后续的处理

finally分支

try:

被检测的代码块

except 异常类型1:

try中一旦检测到此处的异常类型, 就执行这里的逻辑

except 异常类型2:

try中一旦检测到此处的异常类型, 就执行这里的逻辑

except Exception as e:

print(e)

不满足上面的异常类型时, 都会执行这里的逻辑

else:

当try中代码不发生异常的时候, 走else分支

finally:

无论如何都会被执行

应用场景:

例如打开一个文件操作, 如果文件打开了在操作的过程中, 出现问题, 有finally那文件就可以被关闭; 没有出现问题, 文件也会被关闭.

所以, finally可以用来回收一些操作系统的资源: 数据库连接, 打开的文件句柄, 网络连接等

注:

1. 有finally时, finally在最下面

2. 注意这里写的顺序

6.其他操作

6.1主动抛出异常

raise

这个是给其他开发者用的, 而不是给用户抛的

例如:我们使用别人开发的框架, 在使用时可以给我们主动抛出异常让我们处理, 而我们开发完毕的程序, 是不能抛出异常给用户看的, 这样是很不友好的

raise ValueError('你写的不对呀!')

结果:

ValueError: 你写的不对呀!

6.2断言

assert

assert 1 == 1        # 条件成立, 程序继续往下执行
 
assert 1 == 2        # 条件不成立, 程序不会继续往下执行

assert 1 == 1        # 条件成立, 程序继续往下执行

assert 1 == 2        # 条件不成立, 程序不会继续往下执行

