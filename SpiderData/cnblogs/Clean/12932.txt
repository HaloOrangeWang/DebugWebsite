
2022.4.15socket模块及粘包问题

socket套接字

通信循环

链接循环及代码优化

粘包问题.

大文件上传


一、socket套接字


1、socket套接字简介

需求：编写一个CS架构的程序，实现数据交互

思考:需要编写代码操作OSI七层 相当的复杂

由于操作OSI七层是所有cs架构的程序都需要经历的过程 所以有固定的模块

socket套接字技术

socket模块>>>:提供了快捷方式，不需要自己处理每一层


2、socket模块


（1）服务端

cs架构无论是编写还是运行，都应该先考虑服务端，就像有门店运营了才可以接待客人一样


（2）客户端

注意：服务端和客户端首次交互时必须一边时send，一边是recv，两边不能相同，不然程序就会停滞，都在接收信息


二、通信循环

上面的代码我们已经实现了客户端与服务端的交互，但是只能获取和接收一次，因此我们需要解决通信循环问题


三、链接循环及代码优化


问题1：

当我们正常循环代码时，如果客户端突然异常退出的话，服务端就会直接报错，遇到这种情况我们需要让服务端重新回到accept等待新的客户端接入，怎么做呢？


问题2：

反复重启服务端可能会报错>>>:address in use

这个错在苹果电脑报的频繁 windows频率较少


问题3：

发送消息为空时，如何交互

解决方案：len判断长度，为0则直接返回


四、半连接池

服务端使用这种方法是不能同时接收多个客户端消息的，必须要一个个接收，而且接收也是有限制的，这个限制就是listen的参数，这个参数就是最大等待人数，这就是半连接池的概念


五、黏包问题及解决方法


1、粘包问题

TCP协议的特点：

会将数据量比较小并且时间间隔比较短的数据整合到一起发送，并且还会受制于recv括号内的数字大小(核心问题!!!)

流式协议:跟水流一样不间断

eg：

可见不管发送几次消息，都会被整合成一个信息，并且我们不知道接收的信息长度，所以无法判断recv()括号里面该接收多长的信息，反之，如果我们如果能够精确知道它的大小，那么肯定不会出现黏包


2、解决粘包问题

方向：精准获取数据的大小


结论：

pack可以将任意长度的数字打包成固定长度

unpack可以将固定长度的数字解包成打包之前数据真实的长度

可以考虑使用字典封装数据然后再打包


注意：

recv括号内的数字尽量不要写太大 1024 2048 4096足够了

字典数据很难突破上面的数值

