python中捕捉异常常用句式try...except.

try 语句按照如下方式工作；

首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。

首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。

如果没有异常发生，忽略 except 子句，try 子句执行后结束。

如果没有异常发生，忽略 except 子句，try 子句执行后结束。

如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。

如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。

如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。

如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。

一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。

处理程序将只针对对应的 try 子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。

一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如:

接下来我们来写一个具体的demo来看一下：

以上程序可看到try中执行一个未定义的变量，运行报错，报错信息则被下面except给接住了，并输出了具体的错误信息，错误的类型则为NameError 。

若我们将错误类型修改一下，情况如下示例：

会发现执行以上程序仍就报错了，这是因为错误类型本该是NameError ，我们却用IOError 进行接收，发现报错与except中不匹配，则仍旧执行了try中的程序。如果我们在执行时不清楚具体的错误类型，可以用异常的基类，

BaseException或者我们常用的错误类型集合Exception。

try...except...else...

else后面是如果程序执行没有异常的话，则需要在执行一次else里面的内容，若存在异常，则不会执行else里面的内容。

try...finally...

finally后面是无论以上程序有没有异常报错，都会执行finally里面的内容，起到一个兜底的作用。

raise Exception

抛出异常，rasise是我们手动去抛出的一些异常，可能有些业务规则不满足我们的需求，程序又没有语法实质性的错误，所以我们可以自定义抛出错误。

还有一些时候我们捕捉到了异常，并不想对其进行处理，想再次把它抛出去，我们还可以这样写：

以上可看到程序捕捉到了NameError，然后再次将其抛了出去。

